\chapter{State of the Art}

\section{Modeling Frameworks}
Original biological problems are usually difficult to study directly due to the uncertainty and the big scale of biological systems. 
Modeling is a process of abstracting the real system into a more concise and more easily automatized system.
To solve a certain problem, an appropriate modeling framework is crucial because different models have different bias from reality and have also different advantages in computation, e.g. fix point, reachability etc.
Here I introduce several most frequent modeling frameworks and compare their advantages and disadvantages.
\subsection{Boolean Network}
Boolean Network (BN) is a traditional framework used for decades \cite{kauffman1969}.
A BN $G(V,F)$ consists of a set of nodes $V=\{v_1,\cdots,v_n\}$ and a set of Boolean functions $F=(f_1,\cdots,f_n)$ where $f_i(v_1,\cdots,v_n)$ decides the value of node $v_i$.
In some applications, the nodes are classified into incoming nodes, outgoing nodes and inner nodes to represent an input-output system \cite{akutsu2007control}.

\textcolor{red}{Fig BN}
%Un $(h+1)$-dimension vecteur booléen $\mathbf{e}$ est appelé un exemple, où les premiers h éléments correspondent aux nœuds d'entrée et le dernier élément correspond au nœud de sortie. Un exemple exprime les résultats des expériences ou les connaissances existantes. Un réseau booléen $G$ est dit cohérent avec $\mathbf{e}$ si $\hat{v}_n=\mathbf{e}_{h+1}\land\forall\hat{v}_i=\mathbf{e}_i$ où $i=1,\cdots,h$. 
\subsection{Regulatory Network}
Regulatory Network (RN) is more like a static network, representing the interactions between components.
\subsection{Process Hitting}
Describes the dynamics more finely, introduced by Paulev\'e \textit{et al.} \cite{pauleve2011}
\subsection{Automata Network}
Paulev\'e \textit{et al.} have revised the Process Hitting framework \cite{folschette2015}
The Process Hitting framework cannot describe cooperative action, e.g. $\{a,b\}\to c$ and the dynamics with 

\begin{definition}[ABAN]
An ABAN is a triplet $AB = (\Sigma,L,T)$, where:
\begin{itemize}
\item $\Sigma\triangleq\{a,b,\ldots\}$ is the finite set of automata with every component having a Boolean state;
\item $LS\triangleq \underset{a\in \Sigma}{\cup} \{a_0,a_1\}$ is the set of all local states, $L\triangleq \underset{a\in \Sigma'}{\times} \{a_0,a_1\}$ is the set of joint states where $\Sigma'\subseteq\Sigma$. Particularly, if $\Sigma'=\Sigma$, $L$ is the set of global states. 
\item $T\triangleq \{A\rightarrow b_i\mid b\in \Sigma \land A\in L\}$ is the set of transitions, where $A$ (called head) is the set of required state(s) for transition $tr=A\to b_i$ , which allows to flip $b_{1-i}$ to $b_i$ (called body). In other words, transition $tr$ is said fireable iff $A\subseteq s$, where $s$ is the current global state.
\end{itemize}
\end{definition}

A local states represent the state of one automaton, e.g. $a_1$, while a global state represents the joint state of all automata, e.g. $\langle a_0, b_1,c_0 \rangle$ where $L=\{a,b,c\}$.

\begin{definition}[Dynamics]
    From current global state $s$, the global state after firing transition $tr=A\to b_j$ is denoted $s \cdot tr = s \setminus \{b_i\} \cup \{b_j\}, b_i \in s$.
    The state of a certain automaton $a$ is noted $(s\cdot tr)[a]$.
\end{definition}

To describe the evolution in an ABAN, we use the notion of trajectory.
\begin{definition}[Trajectory]
Given an ABAN $AB = (\Sigma,L,T)$ and a global initial state $\alpha\in L$, a trajectory $t$ from $\alpha$ is a sequence of transitions $t=tr_1::\cdots :: tr_i::\cdots ::tr_n$ with $tr_i\in T$ and each $tr_i$ is fireable in $(s \cdot tr_1 \cdot \ldots \cdot tr_{i-1})$.
From $\alpha$, the global state after firing all transitions of $t$ is $(s \cdot tr_1 \cdot \ldots \cdot tr_n)$, denoted $s \cdot t$.
\end{definition}

\begin{definition}[State sequence]
Given an ABAN $AB = (\Sigma,L,T)$ and a global initial state $\alpha\in L$ and trajectory $t$, the state sequence $seq=s_1::\cdots :: s_i::\cdots ::s_n$ with $s_i\in LS$ is formed by the updated local states during the trajectory $t$.
\end{definition}


\begin{example}
    Fig. \ref{exampleABAN} shows an ABAN with initial state $\alpha=\langle a_0,b_0,c_0,d_0,e_0\rangle$ and a possible trajectory is $t=\acm{d_0}{b_0}{b_1}::\acm{b_1}{d_0}{d_1}::\acm{d_1}{c_0}{c_1}::\acm{b_1,c_1}{a_0}{a_1}$.
    After firing the transitions in trajectory $t$, the state becomes $\Omega=s\cdot t=\langle a_1,b_1,c_1,d_1,e_0\rangle$, and $\omega= a_1= (\alpha\cdot t)[a]$. The state sequence is $seq=b_1::d_1::c_1::a_1$.
\end{example}

\begin{figure}[ht]
\centering
\input{exampleAN}
\caption{An example of ABAN}\label{exampleABAN}
\end{figure}
As to reachability problem, given an ABAN, joint reachability $REACH (\Omega)$ can be formalized as: joint state $\Omega$ is reachable iff there exists a trajectory $t$ s.t. $\alpha\cdot t=\Omega$.
Partial reachability $reach(\omega)$ is defined analogously: local state $\omega=a_i$ is reachable iff there exists a trajectory $t$ s.t. $(\alpha\cdot t)[a]=a_i$.
$REACH (\Omega)$ and $reach(\omega)$ take Boolean values \textbf{True}, \textbf{False} or \textbf{Inconclusive} if it cannot be decided.
In Fig. \ref{exampleABAN}, $\Omega=\langle a_1,b_1,c_1,d_1,e_0\rangle$ or $\omega=a_1$ is reachable from initial state $\alpha$ \textit{via} trajectory $t$, \textit{i.e.} $reach(a_1)=\textbf{True}$ and $REACH(\Omega)=\textbf{True}$. 
In fact, the reachability of a joint state even a global state is equivalent to that of one local state. 

\subsection{Translation between Models}
Among the models introduced above, 
\section{Model Checkers}
Model checkers 
\subsection{Traditional Model Checkers}

\subsection{Static Analyzers}
Pint
\section{Semantics of Modelings}
\subsection{Synchronicity}
Def

\begin{figure}[ht]
%\begin{minipage}[ht]{0.32\textwidth}
\subfigure[0.3\textwidth][Synchronous dynamics]{
\begin{tikzpicture}[scale=0.9,line width=1pt]
\draw[->] (0,0) -- (3.5,0);
\draw	[->] (0,0) -- (0,2.5);
\draw[step=1] (0,0) grid (3,2);
\node at (3.5,0)[anchor=north]{\small u};
\node at (0,2.5)[anchor=east]{\small v};
\foreach \x in {0,1,2}
\node at ($(\x,0)+(0.5,0)$)[anchor=north] {\small $\x$};
\foreach \y in {0,1}
\node at ($(0,\y)+(0,0.5)$)[anchor=east] {\small $\y$};
\node at (1,0)[anchor=north]{$t_{uv}$};
\node at (2,0)[anchor=north]{$t_{uu}$};
\node at (0,1)[anchor=east]{$t_{vu}$};
\draw[->] (0.5,1.4) -- (0.5,0.6);
\draw[->] (1.4,1.5) -- (0.6,1.5);
\draw[dotted,->] (0.6,0.5) -- (2.4,0.5);
\draw[dashed,->] (1.6,0.6) -- (2.3,1.3);
\draw[->] (2.5,0.6) -- (2.5,1.4);
\draw[->] (2.6,1.4) arc (-90:240:0.25);
\end{tikzpicture}
%\caption{Synchronous dynamics}
%\end{minipage}
}
%\begin{minipage}[ht]{0.32\textwidth}
\subfigure[0.3\textwidth][Asynchronous dynamics]{
\begin{tikzpicture}[scale=0.9,line width=1pt]
\draw[->] (0,0) -- (3.5,0);
\draw[->] (0,0) -- (0,2.5);
\draw[step=1] (0,0) grid (3,2);
\node at (3.5,0)[anchor=north]{\small u};
\node at (0,2.5)[anchor=east]{\small v};
\foreach \x in {0,1,2}
\node at ($(\x,0)+(0.5,0)$)[anchor=north] {\small $\x$};
\foreach \y in {0,1}
\node at ($(0,\y)+(0,0.5)$)[anchor=east] {\small $\y$};
\node at (1,0)[anchor=north]{$t_{uv}$};
\node at (2,0)[anchor=north]{$t_{uu}$};
\node at (0,1)[anchor=east]{$t_{vu}$};
\draw[->] (0.5,1.4) -- (0.5,0.6);
\draw[->] (1.4,1.5) -- (0.6,1.5);
\draw[->] (0.6,0.5) -- (1.4,0.5);
\draw[->] (1.6,0.5) -- (2.4,0.5);
\draw[->] (1.5,0.6) -- (1.5,1.4);
\draw[->] (2.5,0.6) -- (2.5,1.4);
\draw[->] (2.6,1.4) arc (-90:240:0.25);
\end{tikzpicture}
%\caption{Asynchronous dynamics}
%\end{minipage}
}
%\begin{minipage}[ht]{0.32\textwidth}
\subfigure[0.3\textwidth][Generalized dynamics]{
\begin{tikzpicture}[scale=0.9,line width=1pt]
\draw[->] (0,0) -- (3.5,0);
\draw[->] (0,0) -- (0,2.5);
\draw[step=1] (0,0) grid (3,2);
\node at (3.5,0)[anchor=north]{\small u};
\node at (0,2.5)[anchor=east]{\small v};
\foreach \x in {0,1,2}
\node at ($(\x,0)+(0.5,0)$)[anchor=north] {\small $\x$};
\foreach \y in {0,1}
\node at ($(0,\y)+(0,0.5)$)[anchor=east] {\small $\y$};
\node at (1,0)[anchor=north]{$t_{uv}$};
\node at (2,0)[anchor=north]{$t_{uu}$};
\node at (0,1)[anchor=east]{$t_{vu}$};
\draw[->] (0.5,1.4) -- (0.5,0.6);
\draw[->] (1.4,1.5) -- (0.6,1.5);
\draw[->] (0.6,0.5) -- (1.4,0.5);
\draw[->] (1.6,0.5) -- (2.4,0.5);
\draw[->] (1.5,0.6) -- (1.5,1.4);
\draw[->] (2.5,0.6) -- (2.5,1.4);
\draw[->] (2.6,1.4) arc (-90:240:0.25);
\draw[->] (0.4,0.5) .. controls (1.5,0) .. (2.6,0.5);
\draw[->] (1.6,0.6) -- (2.3,1.3);
\end{tikzpicture}
%\caption{General dynamics}
%\end{minipage}
}
\caption{}
\end{figure}
\subsection{Asynchronicity}
\subsection{General Semantics}