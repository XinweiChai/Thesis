\chapter{Representation of Different Models}
\section{Transformation from BNs to ABANs}\label{appendix:trans}

Given Boolean functions $v_i(t+1)=f_i(\mathbf{V}_i)$, with $\mathbf{V}_i$ the set of participating variables among $v_1(t),\cdots,v_n(t)$.
Boolean functions could be transformed to equivalent CNF (conjunctive normal form) and DNF (disjunctive normal form) if the length of Boolean functions is limited to $O(1)$~\cite{miltersen2005converting} which is often the case.

\begin{proposition}[Transformation from BN to ABAN]
Given a BN $G_B=(V,F)$, with its functions in CNF form $v^i(t+1)=A_1\land\ldots A_j \ldots\land A_n$ and DNF form $v^i(t+1)=A'_1\lor\ldots A_k\ldots\lor A'_m$, an equivalent ABAN $\mathbb{A}$ has transitions $A_j\to v^i_1$ and $\lnot A_k\to v^i_0$ where $A_j$ are disjunctions and $A'_K$ are conjunctions.
\end{proposition}

\begin{example}
Let $G_B=(V,F)$ a BN with $V=\{a,b,c,d,e\}$, and has only one Boolean function, $F=\{f(a)= (b\lor c)\land(d\lor e)\}$, we have 
$f(a)=(b\land d)\lor(b\land e)\lor(c\land d)\lor(c\land e)$, and $\lnot f(a)=(\lnot b\land \lnot c)\lor(\lnot d\land \lnot e)$. 
The equivalent ABAN is then constructed: 5 automata $\mathbf{\Sigma}=\{a,b,c,d,e\}$, with transitions: $\mathbf{T}=\{\acm{b_1,d_1}{a_0}{a_1},\ \acm{b_1,e_1}{a_0}{a_1},\ \acm{c_1,d_1}{a_0}{a_1},\ \acm{c_1,e_1}{a_0}{a_1},\ \acm{b_0,c_0}{a_1}{a_0},\ \acm{d_0,e_0}{a_1}{a_0}\}$.
\end{example}

\section{Multivalued Logic Program}
PermReach and ASPReach can also be applied to multivalued Logic Programs.

\textbf{To be continued}

\chapter{Algorithms}\label{chap:algo}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State \textbf{Input}: a set of annotated atoms $\mathcal{B}$ and a set of state transitions $E$
    \State \textbf{Output}: an NLP $P$
    \State Initialization: $P:= \{var^{val}\gets\varnothing|var^{val}\in \mathcal{B}\}$
    \While{$E\neq \varnothing$}
        \State Pick $(I,J)\in E,E:= E \ \{(I,J)\}$
        \For{$A\in J$}
            \State $R_A^I:= (A\gets\underset{B_i\in I}{\bigwedge}B_i\land \underset{C_j\in (\mathcal{B}\setminus I)}{\bigwedge}\lnot C_j)$
            \State $P:= \mathbf{Specialize}(P,R_A^I)$
        \EndFor
    \EndWhile
    \State\Return $P$
\end{algorithmic}
\caption{Synchronous LFIT}\label{alg:syncLFIT}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State Input: an NLP $P$ and a rule $R$
    \State Output: the maximal specialization of $P$ that does not subsumes $R$
    \State Initialization: $conflicts := \varnothing$
    \State{\textcolor{gray}{// Search rules that need to be specialized}}
    \For{$R_P\in P$}
        \If{$b(R_P)\subseteq b(R)$}
            \State $conflicts := conflicts\cup R_P$
            \State $P := P \setminus R_P$
        \EndIf
    \EndFor
    \State{\textcolor{gray}{// Revise the rules by least specialization}}
    \For{$R_c\in conflicts$}
        \For{$l \in b(R)$}
            \If{$l \not\in b(R_c)$ and $\lnot l \not\in b(R_c)$}
                \State $R'_c=:= (h(R_c) \gets (b(R_c) \cup \{\lnot l\}))$
                \If{$P$ does not subsumes $R_c$}
                    \State $P := P \setminus$ all the rules subsumed by $R'_c$
                    \State $P := P \cup R'_c$
                \EndIf
            \EndIf
        \EndFor
    \EndFor
    \State\Return $P$
\end{algorithmic}
\caption{\textbf{Specialize} in synchronous LFIT algorithm% in~\cite{ribeiro2015learning}
}\label{alg:specializeLFIT}
\end{algorithm}


\begin{algorithm}[ht]
\begin{algorithmic}
    \State Input: an ABAN $\mathbb{A}=(\Sigma,T)$, an initial state $\alpha$, a target state $\omega$
    \State Output: SLCG $l=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$
    \State Initialization: 
    $Ls\gets \{\omega\}$, $V_{\mathrm{state}}\gets\varnothing$, $V_{\mathrm{sol}}\gets \varnothing$, $E\gets \varnothing$
    \While{$Ls\neq \varnothing$}
        \State $Ls=Ls\setminus V_{\mathrm{state}}$
    	\For{$a_i\in Ls$}
    		\State $Ls\gets Ls\setminus \{a_i\}$
    		\If{$a_i\in \alpha$}
    			%\State $a_i{\rm .next}=sol_{a_i}$
    			%\State $V_{\mathrm{sol}}\gets V_{\mathrm{sol}}\cup \{(a_i,\varnothing)\} $
    			\State $E\gets E\cup \{(a_i,\varnothing)\} $
                %\State $sol_{a_i}{\rm .next}=\varnothing$
        	\Else
        	    \State{\textcolor{gray}{// Choose the transitions reaching $a_i$}}
        		\For{$sol=A\to a_i\in \mathbf{T}$}
        		    \State $V_{\mathrm{sol}}\gets V_{\mathrm{sol}}\cup \{sol\}$
        		    \State $E\gets E\cup \{(a_i,sol)\} $
        			%\State $a_i{\rm .next}\gets a_i{\rm .next}\cup sol$
        			\State $V_{\mathrm{state}}\gets V_{\mathrm{state}}\cup {A}$
        			\For{$b_j\in A$}
        				%\State $sol{\rm .next}\gets b_j$
        				\State $E\gets E\cup \{(sol,b_j)\} $
        			\EndFor
        			\State $Ls\gets Ls\cup A$
                    \State $V_{\mathrm{state}}\gets V_{\mathrm{state}}\cup Ls$
        		\EndFor
        		\State$V_{\mathrm{sol}}\gets V_{\mathrm{sol}}\cup a_i{\rm .next}$           
        	\EndIf
    	\EndFor
    \EndWhile
    \State\Return{$(V_{\mathrm{state}},V_{\mathrm{sol}},E)$}
\end{algorithmic}
\caption{Construction of SLCG (over-approximation)}\label{AlgConstructLCG}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State Input: an ABAN $\mathbb{A}=(\Sigma,T)$, an initial state $\alpha$, a target state $\omega$
    \State Output: SLCG $l=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$
    \State Initialization: 
    $Ls\gets \{\omega\}$, $V_{\mathrm{state}}\gets\varnothing$, $V_{\mathrm{sol}}\gets \varnothing$, $E\gets \varnothing$, $rev\gets \varnothing$
    \While{$Ls\neq \varnothing$}
        \State $Ls=Ls\setminus V_{\mathrm{state}}$
    	\For{$a_i\in Ls$}
    		\State $Ls\gets Ls\setminus \{a_i\}$
    		\If{$a_i\in \alpha$}
    			\State $E\gets E\cup \{(a_i,\varnothing)\}$
    			\State $rev\gets rev\cup a_i$
        	\Else
        	    \State{\textcolor{gray}{// Check if local initial state $a_{1-i}$ needs to be revised}}
        	    \If{$a_{1-i}\in rev$}
        	        \State $Ls\gets Ls\cup \{a_{1-i}\}$
        	        \State $\alpha\gets\alpha\setminus\{a_{1-i}\}$
        	    \EndIf
        	    \State{\textcolor{gray}{// Choose the transitions reaching $a_i$}}
        		\For{$sol=A\to a_i\in \mathbf{T}$}
        		    \State $V_{\mathrm{sol}}\gets V_{\mathrm{sol}}\cup \{sol\}$
        		    \State $E\gets E\cup \{(a_i,sol)\} $
        			%\State $a_i{\rm .next}\gets a_i{\rm .next}\cup sol$
        			\State $V_{\mathrm{state}}\gets V_{\mathrm{state}}\cup {A}$
        			\For{$b_j\in A$}
        				%\State $sol{\rm .next}\gets b_j$
        				\State $E\gets E\cup \{(sol,b_j)\} $
        			\EndFor
        			\State $Ls\gets Ls\cup A$
                    \State $V_{\mathrm{state}}\gets V_{\mathrm{state}}\cup Ls$
        		\EndFor
        		\State$V_{\mathrm{sol}}\gets V_{\mathrm{sol}}\cup a_i{\rm .next}$           
        	\EndIf
    	\EndFor
    \EndWhile
    \State\Return{$(V_{\mathrm{state}},V_{\mathrm{sol}},E)$}
\end{algorithmic}
\caption{Construction of SLCG (under-approximation)}\label{AlgConstructLCGUnder}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State Input: an SLCG $l=(V_{\mathrm{state}}, {V_\mathrm{sol}},E)$, an initial state $\alpha$, a target state $\omega$
    \State Output: a Boolean $reach'$
    \Procedure{pseudoReach}{$s$}
    \State \textcolor{gray}{// If $\omega$ is in initial state, it is already reached}
    \If {$\omega\in \alpha$}
       \State\Return \textbf{True}
    \EndIf
    %\State \textcolor{gray}{// If no solution nodes leads to $s$, $s$ is unreachable}
    \State \textcolor{gray}{// The reachability of $s$ depends on its successor solution nodes}
    \If {$\not\exists (s,sol) \in E$}
        \State\Return \textbf{False}
    \EndIf
    \For{each $(s,sol) \in E$}
        \If{\Call{fireable}{$sol$}}
            \State\Return \textbf{True}
        \EndIf
    \EndFor
    \State\Return \textbf{False}
    \EndProcedure
    \Procedure{fireable}{$sol$}
    \For{each $(sol,s') \in E$}
        \If{\Call{pseudoReach}{$s'$}}
            \State\Return \textbf{False}
        \EndIf
    \EndFor
    \State\Return \textbf{True}
    \EndProcedure
\end{algorithmic}
\caption{Pseudo-reachability $reach'$}\label{algPseudo}
\end{algorithm}

\begin{algorithm}\caption{PermReach}\label{alg:perm}
\begin{algorithmic}
    \State Input: an SLCG $l=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$, an initial state $\alpha$, a target state $\omega$, an integer $k$
    \State Output: reachability $r(\alpha,\omega)$
    \State \textcolor{gray}{// 1) Try to break cycles}%\label{delete_cycle_begin}
    \For{each $ scc=(V'_{\mathrm{state}},V'_{\mathrm{sol}}) \in \mathrm{SCC}(l)$ with $V'_{\mathrm{state}} \subseteq V_{\mathrm{state}},V'_{\mathrm{sol}}\subseteq V_{\mathrm{sol}}$}
        \If{$scc$ has less than one incoming edge}
            \For{each $v \in V'_{\mathrm{state}}$}
                \If {$\exists(v,v')\in E, v' \in (V_{\mathrm{sol}} \setminus V'_{\mathrm{sol}})$}
                    \State $E\gets E\setminus \{(v,v'')|v''\in V'_{\mathrm{sol}},(v,v'')\in E\}$
                \EndIf
            \EndFor
        \EndIf
    \EndFor %\label{delete_cycle_end}
    \State{\textcolor{gray}{// 2) Remove useless nodes/edges}} %\label{prune_begin}
    \State pruned = true
    \While{pruned}
        \State pruned = false
        \For {$v \in V_{\mathrm{state}}$}
            \If{$\not\exists(v,v')\in E$}
                \State $V_{\mathrm{state}} \gets V_{\mathrm{state}}\setminus \{v\}$; $E\gets E\setminus \{ (v'',v)\in E\}$
                \State $E\gets E\setminus \{ (v'',sol)\in E | sol \in \{sol = (A \rightarrow a) \in V_{\mathrm{sol}} | v \in A\}\}$
                \State $V_{\mathrm{sol}} \gets V_{\mathrm{sol}}\setminus \{sol = (A \rightarrow a) \in V_{\mathrm{sol}} | v \in A\}$
                \State pruned = true
            \EndIf
        \EndFor %\label{prune_end}
    \EndWhile
    \State \textcolor{gray}{// 3) Check pseudo-reachability} %\label{pseudo_reach_begin}
    \If {PSEUDOREACH$(l)=\textbf{False}$}
        \State \Return $\mathbf{False}$
    \EndIf %\label{pseudo_reach_end}

    \algstore{myalg}
\end{algorithmic}
\end{algorithm}

\clearpage

\begin{algorithm}
%  \ContinuedFloat
\caption{PermReach (continued)}
\begin{algorithmic}
    \algrestore{myalg}
    \State \textcolor{gray}{// 4) main search loop} %\label{main_loop_begin}
    \For{each $i$ in $1\ldots k$}
        \State $l'=(V'_{\mathrm{state}}, V'_{\mathrm{sol}},E')\gets(V_{\mathrm{state}}, V_{\mathrm{sol}},E)$
        \For{$v \in V'_{state}$} \textcolor{gray}{// Treat each OR gates}
            \State pick a random element $(v,v') \in E'$
            \State $E'\gets E' \setminus  \{(v,v'') \in E'| v''\neq v'\}$
        \EndFor
        \If{$l'$ contains cycles}
            \State \textbf{continue}
        \EndIf
        %\State $(r,t)\gets\mathrm{ASPsolve}(l')$
        \State Obtain simple \textbf{AND gates} $simp$ from $l'$
        \While{$simp\neq \varnothing$}
            \State $re\gets\mathbf{False}$ 
            \State\textcolor{gray}{// check the reachability of $simp$, if true, update initial state}
            \For{$i \in perm(simp)$} 
                \If{$REACH(i)=\mathbf{True}$}
                    \State $re\gets\mathbf{True}$
                    \State \textbf{break}
                \EndIf
            \EndFor
            \If{$re=\textbf{True}$}
                \State update $\alpha$ by firing transitions in $simp$
                \State $V'_{\mathrm{sol}}\gets V'_{\mathrm{sol}} \setminus simp$
            \Else
                \State \textbf{break}
            \EndIf
            \State Obtain simple \textbf{AND gates} $simp$ from $l'$
        \EndWhile
        \If{$re=\textbf{True}$}
            \State\Return{$\mathbf{True}$}
        \EndIf
    \EndFor %\label{main_loop_end}
    \State \Return{$\mathbf{Inconclusive}$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State Input: SLCG $l=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$, an integer $k$
    \State Output: reachability $r$ and a trajectory $t$
    \State Compute SCCs, classify them into $\mathrm{SCC1}(l)$ with at most 1 incoming edge and $\mathrm{SCC2}(l)$ otherwise
    \State \textcolor{gray}{// 1) Break all cycles and prune useless branches}\label{delete_cycle_begin}
    \For{each $(V'_{\mathrm{state}} \subseteq V_{\mathrm{state}},V'_{\mathrm{sol}} \subseteq V_{\mathrm{sol}}) \in \mathrm{SCC1}(l)$}
        \For{each $v \in V'_{\mathrm{state}}$}
        \If {$\exists(v,v')\in E, v' \in (V_{\mathrm{sol}} \setminus V'_{\mathrm{sol}})$}
            \State $E\gets E\setminus \{(v,v'')|v''\in V'_{\mathrm{sol}},(v,v'')\in E\}$
        \EndIf
    \EndFor
    \EndFor \label{delete_cycle_end}
    \State{\textcolor{gray}{// 2) remove useless nodes/edges}} \label{prune_begin}
    \State pruned = \textbf{True}
    \While{pruned}
        \State pruned = \textbf{False}
        \For {$v \in V_{\mathrm{state}}$}
            \If{$\not\exists(v,v')\in E$}
                \State $V_{\mathrm{state}} \gets V_{\mathrm{state}}\setminus \{v\}$; $E\gets E\backslash \{ (v'',v)\in E\}$
                \State $E\gets E\backslash \{ (v'',sol)\in E | sol \in \{sol = (A \rightarrow a) \in V_{\mathrm{sol}} | v \in A\}\}$
                \State $V_{\mathrm{sol}} \gets V_{\mathrm{sol}}\backslash \{sol = (A \rightarrow a) \in V_{\mathrm{sol}} | v \in A\}$
                \State pruned = \textbf{True}
            \EndIf
        \EndFor \label{prune_end}
    \EndWhile
    \State \textcolor{gray}{// 3) Check pseudo-reachability} \label{pseudo_reach_begin}
    \If {$pseudoReach(l)=\textbf{False}$}
        \State \Return $(\mathbf{False},\varnothing)$
    \EndIf \label{pseudo_reach_end}
    
    \State \textcolor{gray}{// 4) main search loop} \label{main_loop_begin}
    \For{each $i$ in $1\ldots k$}
        \State $l'=(V'_{\mathrm{state}}, V'_{\mathrm{sol}},E')\gets(V_{\mathrm{state}}, V_{\mathrm{sol}},E)$ 
        \For{$v \in V'_{state}$} \textcolor{gray}{// Treat each OR gates}
            \State pick a random element $(v,v') \in E'$
            \State $E'\gets E' \backslash  \{(v,v'') \in E'| v''\neq v'\}$ with $\nexists i\in \mathrm{SCC2}(l)$ and $i\in E'$
        \EndFor
        \State $(r,t)\gets\mathrm{ASPsolve}(l')$
        \If{$r=\textbf{True}$}
            \State\Return{$(\mathbf{True},t)$}
        \EndIf
    \EndFor \label{main_loop_end}
    \State \Return{$(\mathbf{Inconclusive},\varnothing)$}
\end{algorithmic}
\caption{ASPReach}\label{algOverall}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Completion by over-approximation}\label{algComOver}
\begin{algorithmic}
    \State Input: an incomplete ABAN $\mathbb{A}=(\Sigma,T)$, a set of candidate regulations $R$, targeted reachability $(\alpha,\omega)$
    \State Output: Completed set $CS$ %or $\varnothing$ if there is no solution
    \State Initialization: $rev\gets\{(\{\omega\},\{\omega\},\varnothing)\}$, $CS\gets \varnothing$
    \State Construct SLCG $l=SLCG(\alpha,\omega)=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$ by Algorithm~\ref{AlgConstructLCG}
    \If {$reach(\alpha,\omega)$}
        \State\Return{$(\mathbf{True},\varnothing)$}
    \EndIf
    \While {$rev\neq \varnothing$}
        \For {$i=(ls,fr,tr)\in rev$}
            \State $rev\gets rev \setminus\{i\}$
            \If{$fr=\varnothing$}
                \State $CS\gets CS\cup \{ls\}$
                \State \textbf{continue}
            \EndIf
            \For{$j\in fr$}
                \For{$k\in j.next$}
                    \If{$head(k)\not\subseteq ls$}
                        \State $rev\gets rev\cup \{(ls\cup head(k), fr\cup head(k)\setminus \{j\},tr)\}$
                    \EndIf
                \EndFor
            \EndFor
            \State $cand\gets\varnothing$
            \For {$j=(b,h,sgn)\in R$}
                \If {$\exists h_x\in fr\land\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\notin T$}
                    \State $cand \gets cand\cup\{\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\}$
                    \State 
                        $\begin{aligned}
                            rev\gets rev\cup &\{(ls\cup \{b_{x \oplus sgn}\}, fr\cup \{b_{x \oplus sgn}\}\setminus \{h_x\},\\
                            &tr\cup\{\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\})\}
                        \end{aligned}$
                \EndIf
            \EndFor
        \EndFor
    \EndWhile
    \If{$CS=\varnothing$}
        \State\Return{$(\mathbf{False},\varnothing)$}
    \EndIf
    \State\Return{$(\mathbf{True},CS)$}
\end{algorithmic}
\end{algorithm}
%Remark: every element in $rev$ is defined as $(ls, fr, tr)$, where

\begin{algorithm}[ht]
\caption{Completion by under-approximation}\label{algComUnder}
\begin{algorithmic}
\State Input: an incomplete ABAN $\mathbb{A}=(\Sigma,T)$, a set of candidate regulations $R$, a targeted reachability $(\alpha,\omega)$
\State Output: Completed set $CS$ %or $\varnothing$ if there is no solution
\State Initialization: $rev\gets\{(\{\omega\},\{\omega\},\varnothing)\}$, $CS\gets \varnothing$, $CS_{iter}\gets \varnothing$
\Do
\State SLCG $l=SLCG(\alpha,\omega)=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$ by Algorithm~\ref{AlgConstructLCGUnder}
\While {$rev\neq \varnothing$}
    \For {$i=(ls,fr,tr)\in rev$}
        \State $rev\gets rev \setminus\{i\}$
        \If{$fr=\varnothing$}
            \State $CS_{iter}\gets CS_{iter}\cup \{ls\}$
            \State \textbf{continue}
        \EndIf
        \For{$j\in fr$}
            \For{$k\in j.next$}
                \If{$head(k)\not\subseteq ls$}
                    \State $rev\gets rev\cup \{(ls\cup head(k), fr\cup head(k)\setminus \{j\},tr)\}$
                \EndIf
            \EndFor
        \EndFor
        \State $cand\gets\varnothing$
        \For {$j=(b,h,sgn)\in R$}
            \If {$\exists h_x\in fr\land\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\notin T$}
                \State $cand \gets cand\cup\{\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\}$
                \State 
                    $\begin{aligned}
                        rev\gets rev\cup &\{(ls\cup \{b_{x \oplus sgn}\}, fr\cup \{b_{x \oplus sgn}\}\setminus \{h_x\},\\
                        &tr\cup\{\acm{b_{x \oplus sgn}}{h_{1-x}}{h_x}\})\}
                    \end{aligned}$
            \EndIf
        \EndFor
    \EndFor
\EndWhile
\State $CS\gets CS\cup CS_{iter}$
\doWhile {$CS_{iter}\neq \varnothing$}
\State \Return{$CS$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State \textbf{Input}: a logic program $P$, a set of state transitions $E$, an unsatisfied element $(\alpha,\omega)$, a reachable set $Re$
    \State \textbf{Output}: modified logic program $P'$ or $\varnothing$ if not revisable
    \State Initialization: $Rev\gets\{\omega\}$
    \Do
    \State $RS\gets \varnothing$
    \For{$R\in P$}
        \If{$h(R)\in Rev$}
            \State $RS\gets RS\cup \{R\}$
        \EndIf
    \EndFor
    \For{$R\in RS$}
        \For{$R'\in ls(R)$}
            \State $P'\gets P\cup \{R'\}\setminus \{R\}$
            \If{$P'$ is consistent with $E$ and $P'$ satisfies $Re$}
                \If {$reach(\alpha,\omega)=\mathbf{False}$}
                    \State\Return $P'$
                \EndIf
            \EndIf
        \EndFor
    \EndFor
    \For{$R\in RS$}
        \State $Rev\gets b(R)$
    \EndFor
    \doWhile{$RS\neq \varnothing$}    
\end{algorithmic}
\caption{Specialization}\label{alg:specialization}
\end{algorithm}

\begin{algorithm}[ht]
\begin{algorithmic}
    \State \textbf{Input}: a logic program $P$, a set of state transitions $E$, an unsatisfied element $(\alpha,\omega)$, an unreachable set $Un$
    \State \textbf{Output}: modified logic program $P'$ or $\varnothing$ if not revisable
    \State Initialization: $Rev\gets\{\omega\}$
    \Do
    \State $RS\gets \varnothing$
    \For{$R\in P$}
        \If{$h(R)\in Rev$}
            \State $RS\gets RS\cup \{R\}$
        \EndIf
    \EndFor
    \For{$R\in RS$}
        \For{$R'\in lg(R)$}
            \State $P'\gets P\cup \{R'\}\setminus \{R\}$
            \If{$P'$ satisfies $Un$}
                \If {$reach(\alpha,\omega)=\mathbf{True}$}
                    \State\Return $P'$
                \EndIf
            \EndIf
        \EndFor
    \EndFor
    \For{$R\in RS$}
        \State $Rev\gets b(R)$
    \EndFor
    \doWhile{$RS\neq \varnothing$}    
\end{algorithmic}
\caption{Generalization}\label{alg:generalization}
\end{algorithm}

\chapter{Proofs}\label{sec:proof}
\begin{theorem}[Change rate of sigmoid function]
    Sigmoid function $S(x)={\dfrac {1}{1+e^{-x}}}$ on $\mathbb{R}$ is monotonically increasing and its change rate is high around $x=0$.
    \begin{proof}
    The derivative of $S(x)$ is $S'(x)=\dfrac{1}{e^x+e^{-x}+2}>0$, thus $S(x)$ is monotonically increasing.
    
    The second derivative of $S(x)$ is $S''(x)=\dfrac{e^{-x}-e^x}{(e^x+e^{-x}+2)^2}$, $S''(x)=0$ iff $x=0$, thus the change rate of $S(x)$ reaches its maximum at $x=0$ and is high around $x=0$.
    \end{proof}
\end{theorem}

\begin{theorem}[Future states of synchronous semantics]
    There are at most $O(3^m)$ possible future states for a system of synchronous update scheme if the number of total states of all the variables is fixed, where $m$ is the number of different variables in all the heads of fireable transitions and $x$ is the max number of qualitative levels in the system. 
    \begin{proof}
         For every variable, there are at most $x$ future states and the sum number of states of all variables is constant $xm=C$.
         
         The amount of future states is $f(x)=x^{\frac{C}{x}}$, $f'(x)=\frac{C}{x}(1-\ln x)$, $f(x)$ takes its maximum at $x=e$.
         As $x$ is integer, we take the nearest value $x=3$.
         Considering that $C$ is integer, the maximum of $f(x)$ is $3^{\round{\frac{C}{3}}}(C-3\ceiling{\frac{C}{3}}+1)$ which is of $O(3^m)$.
    \end{proof}
\end{theorem}

\begin{theorem}[Termination and correctness of ASPReach] ~
    Let $l=(V_{\mathrm{state}}, V_{\mathrm{sol}}, E)$ be an SLCG with initial state $\alpha$ and target local state $\omega$ and $k > 0$ be an integer.
    The call \textit{ASPReach(l,k)} terminates.\\
    $ASPReach(l,k)$=$(\mathbf{False},\varnothing)$ if $\nexists t$ a trajectory in $l$ from $\alpha$ to $\omega$.\\
    $ASPReach(l,k)$=$(\mathbf{True},t)$ only if $\exists t$ a trajectory in $l$ from $\alpha$ to $\omega$.
    \begin{proof}
    
        1: The algorithm starts by breaking all cycles of the SLCG and according to Theorem~\ref{th:break_cycle} it terminates and does not affect the reachability of $\alpha$ in $l$.
        
        2: Then all nodes of $V_{\mathrm{state}}$ and (resp. $V_{\mathrm{sol}}$) with no (resp. missing) outgoing edges are removed.
        Such nodes cannot be part of a trajectory leading to initial state $\alpha$ and thus this operation does not affect the reachability of $\alpha$ in $l$.
        The internal for loop of this operation iterates over $V_{\mathrm{state}}$ which is finite.
        To continue looping, it requires one state deletion thus this operation will terminate at least when $V_{\mathrm{state}}$ becomes $\varnothing$.
        
        Conclusion 1: $ASPReach(l,k)=\mathbf{False}$ if $\nexists t$ a trajectory in $l$ from $\alpha$ to $v \in V_{\mathrm{sol}}$.
        
        Conclusion 2: the call \textit{ASPReach(l,k)} terminates.
        
        Conclusion 3: After this pre-processing, pseudo reachability is checked and according to~\cite{pauleve2012}, it terminates and is correct.
        It is the only possibility for ASPReach to output $\mathbf{False}$.
        
        Conclusion 4: Stochastic search follows by randomly reducing each OR gate of $l$ to one of its edges to form $l'$.
        This operation is run a finite time $k$ and iterates over $V_{\mathrm{state}}$ which is finite and thus it terminates.
        This operation does not create new edges, i.e. $E' \subseteq E$.
        $ASPsolve(l')$ generates all the possible trajectories of $l'$ leading to $\alpha$.
        The number of possible trajectory is finite and thus $ASPsolve(l')$ terminates.
        
        Furthermore when $ASPsolve(l')=(\mathbf{True},t)$, t is a trajectory of $l$ proving reachability of $\alpha$ in $l$ and it is the only possibility for ASPReach to output $\mathbf{True}$.
        
        Conclusion 3: $ASPReach(l,k)=(\mathrm{\mathbf{True}},t)$ only if $\exists t$ a trajectory in $l$ from $\alpha$ to $v \in V_{\mathrm{sol}}$.
    \end{proof}
\end{theorem}

\begin{theorem}[ASPReach complexity]
    Let $l=(V_{\mathrm{state}},V_{\mathrm{sol}}, E)$ be an SLCG with initial state $\alpha$ and $k > 0$ be an integer.
    Let $s=|V_{\mathrm{sol}}|$ be the number of target state of $l$.
    Let $v = |V_{\mathrm{state}}|$ be the number of vertices of $l$.
    Let $e=|E|$ be the number of edges of $l$.
    The complexity of $ASPReach(l,k)$ is $O(v + s + e + (v+s) / 2 \times v \times e \times s + v^{2} \times e + v \times e + k \times (v \times e^{2} + 2^{v}))$ which is bounded by $O(k \times 2^{v})$.
    \begin{proof}
    
        1: The computation of $SCC(l)$ has a complexity of $O(v + s + e)$.
        In the worst case $|SCC(l)| = (v+s) / 2$ and breaking one cycle of $SCC(l)$ is $O(v \times e \times s)$, thus complexity of removing cycle is $op1=O(v+ e + s + (v+s) / 2 \times v \times e \times s)$
        
        2: To remove useless nodes, ASPReach iterates over all local states and checking if one local state has no successor in $l$ requires to iterates over all edges.
        In the worst case, all states will be removed one by one and thus the complexity of this operation is $op2=O(v \times (v+s) \times e)$.
        
        3: Computing pseudo reachability over $l$ which has no loop corresponds to performing a depth-first search on all branches of a tree and thus is bounded by $op3=O((v+s) \times e)$.
        
        4: the stochastic search iterates atmost $k$ times.
        Treating each OR gate to form $l'$ have a cost of $O(v \times e \times e)$
        $ASPsolve(l')$ generates trajectories that can prove reachability of $\alpha$ in $l'$.
        Each trajectory is a sequence where each element of $|V_{\mathrm{state}}|$ appears exactly once.
        It correspond to the number of total order of $|V_{\mathrm{state}}|$ which is $2^{v}$.
        % TODO: the asp program never produce two times the same sequence ?
        Thus $ASPsolve(l')$ is bounded by $O(2^{v})$ and the whole stochastic search by $op4=O(k \times (v \times e^{2} + 2^{v}))$.
        
        Conclusion 1: The complexity of $ASPReach(l,k)$ is $O(op1 + op2 + op3 + op4) = O(v + e + s + (v+s) / 2  \times v \times e \times s + v \times (v+s) \times e + v \times e + k \times (v \times e^{2} + 2^{v}))$.
        
        Conclusion 2: The complexity of $ASPReach(l,k)$ is bounded by $O(k \times 2^{v})$.
    \end{proof}
\end{theorem}

\begin{theorem}[Coverage of under-approximation]\label{th:underapprox}
    \begin{proof}
    \end{proof}
\end{theorem}

\begin{definition}[Rank in digraphs]\label{def:rank}
Given a digraph $G=(V,E)$, the rank of 

\end{definition}


\chapter{Pure ASP reachability analyzer}
\section{ASP Implementation}
\section{Runtime Comparison}
\cite{abdallah2015exhaustive}
\begin{table}[ht]
    \centering
    \footnotesize
    \begin{tabular}{c|c|c|c|c|c|c}
        Model-target & \#automata & ASP-Th & Pint & libddd & GINsim & ASPi-PH\\
        \hline
        ERBB-whole & 20& 2.4s& out& 1m55s& 2m32s& 12s\\
        \hline
        ERBB-sub& 20& 2.6s& 0.03s& 1m55s& -& 5s\\
        \hline
        TCR-whole& 40& - &Inconc& out& out& 4m28s\\
        \hline
        TCR-sub& 40 &- &0.02s& out& -& 1m35s
    \end{tabular}
    \caption[Performance of pure ASP method]{Compared performances of Rocca et al. method~\cite{rocca2014asp} denoted by ASP-Th, Pint, libddd, GINsim and our new iterative method ASP-PH}
    \label{tab:pureAsp}
\end{table}